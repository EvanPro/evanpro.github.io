<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Evan">



    <meta name="description" content="少年书生志气宏">



<title>HashMap实现原理 | Evan&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
            <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


        
    


<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.3.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Evan&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Evan&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">HashMap实现原理</h1>
            
                <div class="post-meta">
                    

                    
                        <span class="post-time">
                        发表于: <a href="#">四月 16, 2019</a>
                        </span>
                    
                    
                        <span class="post-category">
                    分类于:
                            
                                <a href="/categories/java/">java</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p><code>HashMap</code>是Java中比较常用的集合类，它的实现原理也是面试中经常被问到的问题。在JDK8中，HashMap的实现和JDK7中是不一样的，主要有两方面的改进：</p>
<ul>
<li>数据结构：由原来的数组+链表变更为数组+链表+红黑树。</li>
<li>寻址优化：JDK7 中通过对 key 值Hash取模的方式定位 value 在数组中的下表位置，JDK8中对hash值的计算发生了变化。</li>
</ul>
<p>顾名思义，<code>HashMap</code>是一种基于<strong>哈希表</strong>的Map接口实现。根据<code>HashMap</code>类的注释可以获得几个关键信息：</p>
<ul>
<li>它和<code>Hashtable</code>基本一样，区别在于<code>HashMap</code>不是同步容器，并且允许null作为value和key。</li>
<li><code>HashMap</code>是无序的。</li>
<li>有两个参数会影响<code>HashMap</code>的性能：<strong>initial capacity</strong>，初始容量，默认值16；<strong>load factor</strong>，加载因子，默认值0.75。</li>
<li>线程不安全，如果多个线程并发访问一个<code>HashMap</code>，并且至少有一个线程在结构上修改了<code>HashMap</code>，则必须进行外部同步。（结构修改是指添加或删除一个或多个映射的任何操作；仅更改与<code>HashMap</code>已包含的键关联的值不是结构性修改）。</li>
</ul>
<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>将对象转为有限范围的正整数的表示方法，就叫作 Hash，翻译过来叫散列，也可以直接音译为哈希。将对象进行 Hash，用得到的 Hash 值作为数组下标，将对应元素存在数组中。这个<strong>数组</strong>就叫作哈希表。这样我们就可以利用数组的随机访问特性，达到 O(1) 级别的查询性能。<br>在<code>HashMap</code>中，这个数组也就是哈希表就是HashMap类的字段，需要注意，数组是在<strong>第一次使用</strong>的时候才进行初始化的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment"> * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment"> * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment"> * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>
<p>而数组中的元素自然就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment"> * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，任何 Hash 函数都有可能造成对象不同，但 Hash 值相同的冲突。而且，数组空间是有限的，只要被 Hash 的元素个数大于数组上限，就一定会产生冲突。因为数组空间不可能无限增大，再理想的 Hash 函数也无法避免冲突的发生，因此需要在冲突发生时提供存储和查询的方案，常用的有两种：“开放寻址法”和“链表法”。</p>
<h2 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h2><p>开放寻址法是指在冲突发生后，最新的元素需要寻找新空闲的数组位置完成插入。</p>
<h3 id="线性探查"><a href="#线性探查" class="headerlink" title="线性探查"></a>线性探查</h3><p>在当前位置发现有冲突以后，就顺序去查看数组的下一个位置，看看是否空闲。如果有空闲，就插入；如果不是空闲，再顺序去看下一个位置，直到找到空闲位置插入为止。查找的逻辑与插入的逻辑一样。<br>不难发现，哈希表越满的时候，搜索空位置的时间复杂度就越高，因此，线性探查会影响哈希表的整体性能，而不只是Hash值冲突的Key。</p>
<h3 id="二次探查-amp-双散列"><a href="#二次探查-amp-双散列" class="headerlink" title="二次探查 &amp; 双散列"></a>二次探查 &amp; 双散列</h3><p>二次探查就是将线性探查的步长从 i 改为 i^2。第一次探查，位置为 Hash(key) + 1^2；第二次探查，位置为 Hash(key) +2^2，依此类推。<br>双散列就是使用多个 Hash 函数来求下标位置，当第一个 Hash 函数求出来的位置冲突时，启用第二个 Hash 函数，算出第二次探查的位置，依此类推。<br>两者的核心思路其实都是在发生冲突的情况下，将下个位置尽可能地岔开，让数据尽可能地随机分散存储，来降低对不相干 Key 的干扰，从而提高整体的检索效率。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>开放寻址法的缺点是当哈希表快满了的时候插入和检索的性能会下降的厉害，而且一旦哈希表满了就需要re-hash，会造成非常大的开销，因此不适合数据动态变化的场景。<br>此外，使用开放寻址法在删除元素的时候不能直接删除，而是需要设置标志位。在C语言的哈希表实现khash.h使用的就是开放寻址法，但是JDK8的HashMap并不是。</p>
<h2 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h2><p>链表法是指在数组中不存储一个具体元素，而是存储一个<strong>链表头</strong>。如果一个 Key 经过 Hash 函数计算，得到了对应的数组下标，那么就将它加入该位置所存的链表的尾部。链表法结合了数组和链表，既利用了数组的随机访问特性，又利用了链表的动态修改特性，同时提供了快速查询和动态修改的能力。但是，如果链表很长，遍历代价还是会很高。在JDK8的HashMap实现中，会在链表长度超过8的时候转变为红黑树，在长度小于6的时候再退化回链表。</p>
<h2 id="哈希表的缺点"><a href="#哈希表的缺点" class="headerlink" title="哈希表的缺点"></a>哈希表的缺点</h2><p>哈希表接近 O(1) 的检索效率是有前提条件的，就是哈希表要足够大和有足够的空闲位置，否则就会非常容易发生冲突。如果频繁发生冲突，大部分的数据会被持续地添加到链表或二叉检索树中，检索也会发生在链表或者二叉检索树中，这样检索效率就会退化。这也就是上面所说的<strong>初始容量</strong>和<strong>加载因子</strong>对HashMap性能的影响很大的原因。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>put方法中调用了两个方法：<code>putVal()</code>和<code>hash()</code>。</p>
<h3 id="putVal"><a href="#putVal" class="headerlink" title="putVal()"></a>putVal()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 注意此处的寻址方法</span></span><br><span class="line marked">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里注意代码的第7行，<code>tab[i = (n - 1) &amp; hash])</code>，这一行其实是用key的hash值对哈希表长度取模从而确定元素在哈希表上的位置。但是这里明明是<strong>与运算</strong>（两者同为1时，结果才为1，否则为0）为什么说是取模呢？对于现代的处理器来说，除法和求余数（模运算）是最慢的动作。根据公式<br>$$h \mod 2^n = h \&amp; (2^n - 1)$$<br>可以使用与运算代替取模运算，从而提高计算性能。上述公式也就解释了为什么哈希表的长度总是<strong>2的指数幂</strong>了。<br>整个流程如图：</p>
<img src="/2019/04/16/java/hashmap/hashmap-put.png" class="">
<h3 id="hash"><a href="#hash" class="headerlink" title="hash()"></a>hash()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法就是JDK8对寻址的优化了，将hash值的高16位和低16位做<strong>异或运算</strong>（两者相同为1，不同为0）。为什么这么做呢？源码注释里也有解释：因为哈希表使用2的指数幂作为<strong>掩码</strong>与hash值做与运算进行寻址。这样无论两个hash值的高位多么的不一样，但是只要最后几位是一样的，那么它们计算出来的值就是一样的，从而发生hash冲突。</p>
<img src="/2019/04/16/java/hashmap/hash.png" class="">
<p>所以，JDK8将hash值的高16位和低16位做异或运算，从而将高16位的影响向下传播（spreads the impact of higher bits downward），从而让异或运算结果的低16位融合了原hash值的高16位和低16位的联合特征，这样可以降低哈希冲突从而在一定程度上保证了数据的均匀分布。</p>
<h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 如果哈希表为空就返回null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过hash值寻址，如果在哈希表上就直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 如果不在并且存在链表或者红黑树</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果是红黑树node，那么使用红黑树的检索方法</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 如果是链表，遍历</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get方法的逻辑很简单，直接看注释就好了。</p>
<h2 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h2><p>先看源代码的注释：</p>
<blockquote>
<p>Initializes or doubles table size.  If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using <strong>power-of-two expansion</strong>, the elements from each bin must either <strong>stay at same index, or move with a power of two offset</strong> in the new table.</p>
</blockquote>
<p>注释说明resize方法用来初始化或者将哈希表的长度变为原来的2倍，也就是扩容逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line marked">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line marked">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line marked">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>) <span class="comment">// 普通元素</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 红黑树</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order 链表</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line marked">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>resize方法大致分为两步：确定扩容后哈希表的容量newCap和扩容阈值newThr；元素迁移。</p>
<h3 id="确定容量和阈值"><a href="#确定容量和阈值" class="headerlink" title="确定容量和阈值"></a>确定容量和阈值</h3><ol>
<li>如果扩容前哈希表的容量大于0，判断容量是否超过最大容量值（2<sup>30</sup>）：如果超过则将阈值设置为<code>Integer.MAX_VALUE</code>也就是2<sup>31</sup>-1，并直接返回扩容前哈希表，不进行扩容操作，因为此时oldCap * 2比Integer.MAX_VALUE大，因此无法进行重新分布，只是单纯的将阈值扩容到最大；如果容量 * 2小于最大容量并且不小于默认初始容量（16），则将容量和阈值设置为原来的<strong>两倍</strong>。</li>
<li>如果扩容前哈希表的容量为0并且阈值大于0（这种情况发生在新创建的HashMap第一次put时，该HashMap初始化的时候传了初始容量，由于HashMap并没有capacity变量来存放容量值，因此传进来的初始容量是存放在threshold变量上（查看HashMap(int initialCapacity, float loadFactor)方法），因此扩容前哈希表的threshold就是我们要新创建的HashMap的capacity，所以将扩容后哈希表的容量设置为扩容前的阈值。</li>
<li>如果扩容前哈希表的容量为0并且阈值为0，这种情况是没有传容量的new方法创建的空哈希表，将阈值和容量设置为默认值。</li>
</ol>
<h3 id="元素迁移"><a href="#元素迁移" class="headerlink" title="元素迁移"></a>元素迁移</h3><p>计算完阈值和容量后，从31行开始，遍历当哈希表，rehash所有元素。如果当前位置的元素不为null，那么将哈希表上当前位置置为null，然后处理这个元素，会有3种情况：普通元素（next指针位null）、红黑树元素、链表的头节点。如果是普通元素，就是重新计算此元素在新哈希表上的位置，并放置这个元素；如果是红黑树元素，那么调用split方法rehash。  </p>
<h4 id="处理链表"><a href="#处理链表" class="headerlink" title="处理链表"></a>处理链表</h4><p>从代码第39行开始，是元素为链表头节点的情况，先是声明了类似头尾指针的东西，然后遍历链表上的每一个元素，计算<code>e.hash &amp; oldCap</code>是否为0做了不同处理。<code>e.hash &amp; oldCap</code>代表什么呢？<br>首先由上一步我们知道，<strong>每次扩容后的哈希表容量（newCap）都是扩容前（oldCap）的2倍，并且都是2的指数幂</strong>。我们根据hash计算元素在哈希表上的索引位置时是通过<code>(cap - 1) &amp; hash</code>计算的。假设扩容前的容量为16，即oldCap=16，则扩容后的容量为16*2=32。我们现在处理的是链表，那么必然是两个元素的hash值不同，但是计算哈希表位置后发生了冲突，因此就有了如下图的情况：</p>
<img src="/2019/04/16/java/hashmap/resize.png" class="">
<p>计算1和计算2分别是扩容前发生冲突的两个元素和扩容后这两个元素的哈希表位置的情况。可以看到，扩容后元素的索引位置只取决于元素hash值倒数第5位的值，哈希表元素扩了2倍就相当于参与hash值寻址计算的掩码大了1位。由此就可以通过<code>e.hash &amp; oldCap</code>（也就是计算3）是否等于0得出元素扩容后的索引位置是应该<strong>保持不变</strong>还是等于 <strong>&lt;原索引位置+原容量&gt;</strong> 。通过这种方法，HashMap在对链表扩容时，不需要重新计算元素的索引位置，而是通过计算<code>e.hash &amp; oldCap</code>是否为0，采用队尾插入法（这样可以保证顺序，也是JDK8的一个优化）将链表拆分为了<code>Node&lt;K,V&gt; loHead</code>（索引位置不变）和<code>Node&lt;K,V&gt; hiHead</code>（原索引位置+原容量）两个链表。</p>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>看完上面的内容，再碰到一些常见的面试题，就很好解答了。</p>
<h2 id="为什么HashMap-哈希表长度总是2的n次幂？"><a href="#为什么HashMap-哈希表长度总是2的n次幂？" class="headerlink" title="为什么HashMap 哈希表长度总是2的n次幂？"></a>为什么HashMap 哈希表长度总是2的n次幂？</h2><p>为了提高性能，CPU计算<strong>与运算</strong>比<strong>取模运算</strong>快。根据公式$h \mod 2^n = h \&amp; (2^n - 1)$，可以将取模运算转化为与运算。</p>
<h2 id="为什么当链表过深时，使用红黑树而不是二叉检索树或者平衡二叉树（AVL）？"><a href="#为什么当链表过深时，使用红黑树而不是二叉检索树或者平衡二叉树（AVL）？" class="headerlink" title="为什么当链表过深时，使用红黑树而不是二叉检索树或者平衡二叉树（AVL）？"></a>为什么当链表过深时，使用红黑树而不是二叉检索树或者平衡二叉树（AVL）？</h2><p>二叉检索树只维护了节点间的顺序，因此在特殊情况时会出现二叉检索树退化为链表的情况。为了解决这个问题，又出现了2个变种，AVL 树（平衡二叉树）和红黑树。它们本质上都是二叉检索树，但它们都在保证左右子树差距不要太大上做了特殊的处理，保证了检索效率。<br>之所以选择红黑树而不是AVL树的原因是，红黑树被称为弱AVL树，牺牲了严格的高度平衡的优越条件为代价（根节点到叶子节点的距离最长不会是最短的两倍即可），同时由于红黑树的设计，任何不平衡都会在三次旋转之内解决。相比于AVL树来说，红黑树没有AVL树那么平衡，但是<strong>可以保证O(log2 n)的检索效率的同时，维护平衡性的成本更低</strong>，所以再HashMap这种需要频繁插入和删除的场景中，红黑树更合适。</p>
<h2 id="HashMap加载因子为什么是0-75？转化红黑树阈值为8？"><a href="#HashMap加载因子为什么是0-75？转化红黑树阈值为8？" class="headerlink" title="HashMap加载因子为什么是0.75？转化红黑树阈值为8？"></a>HashMap加载因子为什么是0.75？转化红黑树阈值为8？</h2><p>这个问题，我个人觉得多少有些卷了。。。  其实在源码中这几个参数的取值，注释中都有说明，更多的是统计学上的东西。<br>这两个值是相辅相成，先说加载因子，加载因子衡量的是一个散列表的空间的使用程度，加载因子越大，对空间的利用更充分，然而后果是发生冲突的几率变高，查找效率的降低。那为啥是0.75呢？其实这个并没有一个统一的结论，目前不同语言的 defaultLoadFactor 并不一样，比如 Java 是 0.75，Go 中是 0.65，Dart 中是0.8，python 中是0.762。<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/10901752/what-is-the-significance-of-load-factor-in-hashmap">Stackoverflow上有一个推理的思路</a>，感兴趣的可以看一看。<br>转化红黑树阈值为什么是8，这个其实是基于defaultLoadFactor = 0.75这个设定的。根据源代码中的注释说明：红黑树节点占用的存储空间是普通节点的2倍，因此JDK8增加了红黑树的实现只是为了在冲突非常多的时候保证HashMap的查询效率。实际上，如果hashcode的分布不是特别特殊的情况下，转化为红黑树的机会不应该是特别大的。为了较少转化为红黑树的可能性，就需要知道桶中元素个数和其对应的概率是怎样的并选择一个概率较低的值作为阈值。由于桶中元素个数的概率分布满足<strong>泊松分布</strong>，根据计算，元素个数达到8的概率为0.00000006，足够小，因此转化红黑树的阈值就设置为了8。要注意，这个计算过程，defaultLoadFactor = 0.75是作为参数代入得，所以如果defaultLoadFactor发生了改变，那么转化红黑树的阈值可能也就需要跟着改变了。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/NYfor2017/article/details/105454097">HashMap的加载因子为什么是0.75？</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jajian/p/13965678.html">周末我把HashMap源码又过了一遍</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIxODM4ODg1Mg==&mid=2247484278&idx=1&sn=cee225fc318d3a94e05ddba1b8f9035f&chksm=97ea036da09d8a7b839b99c4cda075b620dbb10d61944c999fd0ac3bede3adc94d680976e8a2&scene=21#wechat_redirect">HashMap加载因子为什么是0.75？转化红黑树阈值为8？</a></li>
</ul>

        </div>

        
        <section class="post-tags">
            <div>
                <span>标签:</span>
                <span class="tag">
                    
                    
                        <a href="/tags/hash-table/"># hash table</a>
                    
                        <a href="/tags/data-structure/"># data structure</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">返回</a>
                <span>· </span>
                <a href="/">首页</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2019/04/18/java/concurrenthashmap/">ConcurrentHashMap实现原理</a>
            
            
            <a class="next" rel="next" href="/2018/05/01/JCIP/1/">结构化并发应用程序</a>
            
        </section>


    </article>
</div>

        </div>
        <!-- <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Evan | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>
 -->
    </div>
</body>
</html>
